#!/bin/sh

##H Usage: manage ACTION [SECURITY-STRING]
##H
##H Available actions:
##H   help        show this help
##H   version     get current version of the service
##H   status      show current service's status
##H   sysboot     start server from crond if not running
##H   restart     (re)start the service
##H   start       (re)start the service
##H   stop        stop the service
##H
##H For more details please refer to operations page:
##H   https://twiki.cern.ch/twiki/bin/view/CMS/DASOperation

if [ $(id -un)  = cmsweb ]; then
  echo "ERROR: please use another account" 1>&2
  exit 1
fi

echo_e=-e
case $(uname) in Darwin )
  md5sum() { md5 -r ${1+"$@"}; }
  echo_e=
  ;;
esac

ME=$(basename $(dirname $0))
TOP=$(cd $(dirname $0)/../../.. && pwd)
ROOT=$(cd $(dirname $0)/../.. && pwd)
CFGDIR=$(cd $(dirname $0) && pwd)
LOGDIR=$TOP/logs/$ME
STATEDIR=$TOP/state/$ME
COLOR_OK="\\033[0;32m"
COLOR_WARN="\\033[0;31m"
COLOR_NORMAL="\\033[0;39m"
# the files will be downloaded here, before verification, and only afterwards moved to STAGEDIR
TMPDIR="/tmp/das_down"
VALIDATORDIR=$CFGDIR
STAGEDIR=$STATEDIR/stagingarea


. $ROOT/apps/mongo/etc/profile.d/init.sh
cd $STATEDIR

# Update and clean a MongoDB database(s) and its collections
# Parameters:
# 1: object_name
# 2: array of strings specifying db_collection  to be updated
#
# If the update scripts have changes this will happen:
# * call clean_${object_name}.js
# * import update_{db_col,..}.js files into mongodb
# TODO: what if we passed well-formed file-names?
update_db()
{
  obj="$1"
  updates="$2"

  # calculate stamp over (possibly multiple) collection updates
  echo "update_db($1)"
  stamp=$(cd $STAGEDIR && printf "%s\n" "${updates[@]}" | xargs -i md5sum "update_{}.js")
  oldstamp=$(cat ${STAGEDIR}/${obj}-schema-stamp 2>/dev/null)
  #echo "stamp: $stamp  oldstamp: $oldstamp"
  if [ ! -f ${STAGEDIR}/${obj}-schema-stamp ] || [ X"$oldstamp" != X"$stamp" ]; then
    set -e
    # this seem to exit with 0 even if DB being cleaned do not exist
    # still we have to check if clean script exists, in case of multiple collections...
    if [ -f ${STAGEDIR}/clean_${obj}.js ]; then
        echo "Clean ${obj}"
        mongo --port 8230 ${STAGEDIR}/clean_${obj}.js
    fi

    for entry in ${updates[@]}
    do
        # TODO: should db name be part of filename? IMHO, that's more flexible.
        db=$(echo ${entry} | cut -f1 -d_) coll=$(echo ${entry} | cut -f2- -d_)
        echo "Updating db: ${db} col: ${coll}"
        mongoimport --port 8230 --db ${db} --collection ${coll} --file ${STAGEDIR}/update_${entry}.js
    done
    # TODO: what if some file is missing?!
    echo "$stamp" > ${STAGEDIR}/${obj}-schema-stamp
    set +e
  fi
}


# download a file
getfile()
{
    file=$1
    fname=`basename $file`
    # Fetch DAS map JSON file from given URI
    regex='(https|http)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|].js'
    if  [ -f $file ]; then
        cp $file $TMPDIR/$fname
    elif [[ $file =~ $regex ]]; then
        # download or fail silently
        curl -s -f $file > $TMPDIR/$fname
        status=$?
        if [ $status -ne 0 ]; then
            echo "failure downloading"
            exit -1
        fi

    else
        echo "Invalid update file name: $file, please provide either URL or full file name"
    fi
}

# Download the files listed in $1.conf and validate them
download_and_verify(){
    val_cmd_src='__ROOT__'    
    CFG=$CFGDIR/$1.conf
    
    # download the files
    while read -r file; do
        if [[ $file =~ '.js' ]]; then
            echo "Get $file"
            getfile "$file"
        fi
    done < "$CFG"
    
    # verify them
    updates=$(cat $CFG | grep update | xargs -i basename '{}' '.js')
    validator=`cat $CFG | grep $val_cmd_src | sed "s,__ROOT__,$VALIDATORDIR,"`
    #update_list=$(printf "%s " "${updates[@]}" | tr -d '\n')
    #echo "Verifying updates: ${updates[*]}"
    for upd in ${updates[@]}
    do
        echo $validator "$TMPDIR/$upd.js"
        $validator "$TMPDIR/$upd.js"
        validator_status=$?
        if  [ "$validator_status" -ne "0" ]; then
            echo "Fail validation of $upd"
            exit 1
        fi        
    done
}

# perform an update
doupdate(){
    CFG=$CFGDIR/$1.conf
    # list of items to update
    updates=$(cat $CFG | grep update | xargs -i basename '{}' '.js' | sed "s,update_,,")
    db=$1
    update_db "$db" "${updates[@]}"
}

# Update DAS maps and KWS data (keylearning)
updatemaps()
{
    # TODO: where to store "clean" scripts! in mongodb/config or repo?

    # cleanup temporary directory where files will be downloaded
    rm -rf "$TMPDIR"
    mkdir -p $TMPDIR

    # TODO: shall anything be updated if something fails to be validated?
    download_and_verify "das"
    download_and_verify "keylearning"
    download_and_verify "inputvals"

    # by now, all the required files are validated and stay in $TMPDIR
    # copy them to STAGEDIR
    rm -f $STAGEDIR/*.js # but leave stamps
    cp -f $TMPDIR/*.js $STAGEDIR/
    # update the database
    doupdate "das"
    doupdate "keylearning"
    doupdate "inputvals"
}

# Start service conditionally on crond restart.
sysboot()
{
  PID=$(cat $STATEDIR/db/mongod.lock 2>/dev/null)
  if [ X"$PID" = X ] || [ $(ps -o pid= -p $PID | wc -l) = 0 ]; then
    # must clean-up improper shutdown
    rm -rf $STATEDIR/db/*
    rm -f $PWD/stagingarea/*-schema-stamp
    start
  fi
}

# Start the service.
start()
{
  echo "starting $ME"
  if  [ -f /usr/bin/numactl ]; then
      cmd="numactl --interleave=all"
  else
      cmd=""
  fi
  $cmd $MONGO_ROOT/bin/mongod --dbpath=$STATEDIR/db \
      --port 8230 --nohttpinterface --bind_ip 127.0.0.1 \
      </dev/null 2>&1 | rotatelogs $LOGDIR/mongodb-%Y%m%d.log 86400 >/dev/null 2>&1 &

  n=0 started=false
  while [ $n -le 100 ]; do
    curl -s 127.0.0.1:8230 | grep -q 'You are trying to access MongoDB' &&
      started=true && break
    echo "waiting for $ME..."
    sleep 1
    n=$(expr $n + 1)
  done

  if $started; then
    echo "$ME is ready"
  else
    echo "$ME did not start, not cleaning nor updating."
    exit 1
  fi
}

# Stop the service.
stop()
{
  echo "stopping $ME"
  PID=$(cat $STATEDIR/db/mongod.lock 2>/dev/null)
  if [ X"$PID" != X ]; then
    kill -INT $PID
    n=0
    while [ -s $STATEDIR/db/mongod.lock -a $n -le 10 ]; do
      echo "Waiting for mongod to exit..."
      n=$(expr $n + 1)
      sleep 1
    done
  fi
}

# Check if the server is running.
status()
{
  PID=$(cat $STATEDIR/db/mongod.lock 2>/dev/null)
  if [ X"$PID" != X ] && [ $(ps -p $PID | wc -l) != 0 ]; then
    echo $echo_e "$ME is ${COLOR_OK}RUNNING${COLOR_NORMAL}, PID" $PID
  else
    echo $echo_e "$ME is ${COLOR_WARN}NOT RUNNING${COLOR_NORMAL}."
  fi
}

# Verify the security string.
check()
{
  CHECK=$(echo "$1" | md5sum | awk '{print $1}')
  if [ $CHECK != 94e261a5a70785552d34a65068819993 ]; then
    echo "$0: cannot complete operation, please check documentation." 1>&2
    exit 2;
  fi
}

# Main routine, perform action requested on command line.
case ${1:-status} in
  sysboot )
    sysboot
    ;;

  start | restart )
    check "$2"
    stop
    start
    updatemaps
    ;;

  status )
    status
    ;;

  stop )
    check "$2"
    stop
    ;;

  updatemaps )
    updatemaps
    ;;

  help )
    perl -ne '/^##H/ && do { s/^##H ?//; print }' < $0
    ;;

  version )
    echo "$MONGO_VERSION"
    ;;

  * )
    echo "$0: unknown action '$1', please try '$0 help' or documentation." 1>&2
    exit 1
    ;;
esac
