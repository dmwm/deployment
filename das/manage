#!/bin/sh

##H Usage: manage ACTION [SECURITY-STRING]
##H
##H Available actions:
##H   help        show this help
##H   version     get current version of the service
##H   status      show current service's status
##H   sysboot     start server from crond if not running
##H   restart     (re)start the service
##H   start       (re)start the service
##H   stop        stop the service
##H   bootstrap   fetch dtata from services: accepted input values and what fields available in services results
##H   syncdata    synchronize the metadata in staging dir to be uploaded to MongoDB
##H   resetdata   reset metadata to the default state as comming with the RPM


##H
##H For more details please refer to operations page:
##H   https://twiki.cern.ch/twiki/bin/view/CMS/DASOperation

if [ $(id -un)  = cmsweb ]; then
  echo "ERROR: please use another account" 1>&2
  exit 1
fi

echo_e=-e
case $(uname) in Darwin )
  md5sum() { md5 -r ${1+"$@"}; }
  echo_e=
  ;;
esac

ME=$(basename $(dirname $0))
TOP=$(cd $(dirname $0)/../../.. && pwd)
ROOT=$(cd $(dirname $0)/../.. && pwd)
CFGDIR=$(dirname $0)
LOGDIR=$TOP/logs/$ME
STATEDIR=$TOP/state/$ME
COLOR_OK="\\033[0;32m"
COLOR_WARN="\\033[0;31m"
COLOR_NORMAL="\\033[0;39m"
PID_DAS_SERVER="$STATEDIR/das_web_server.pid"


. $ROOT/apps/$ME/etc/profile.d/init.sh

export DAS_ROOT YUI_ROOT
export PYTHONUNBUFFERED=1
export DAS_PYTHONPATH=$DAS_ROOT/lib/python2.6/site-packages
export DAS_JSPATH=$DAS_ROOT/lib/python2.6/site-packages/src/js
export DAS_CSSPATH=$DAS_ROOT/lib/python2.6/site-packages/src/css
export DAS_TMPLPATH=$DAS_ROOT/lib/python2.6/site-packages/src/templates
export DAS_IMAGESPATH=$DAS_ROOT/lib/python2.6/site-packages/src/images
export X509_USER_PROXY=$STATEDIR/proxy/proxy.cert
export X509_USER_CERT=$X509_USER_PROXY
export X509_USER_KEY=$X509_USER_PROXY
export DAS_CONFIG=$CFGDIR/das_cms.py
export DAS_KWS_IR_INDEX=$STATEDIR/kws_index
export STAGEDIR=$STATEDIR/mongodb_staging
export METADATA_TMP_DIR=$STATEDIR/metadata_tmp  # directory where temporary files are stored

cd $STATEDIR

# get list of das pids including the process which updates db on restart
# (and its subprocessess)
get_das_pids(){
  local pid
  pgrep -u $(id -u) -f "[/]das_server.py"

  # get the pid of process that updates mongodb and later runs DAS
  if [ -e "${PID_DAS_SERVER}" ]; then
      pid=$(cat "${PID_DAS_SERVER}")
      # at least make sure the proc still exists and it has same uid
      if pgrep -u $(id -u) -f | grep -q "${pid}"; then
        echo "${pid}"
        # list all the subprocessess
        # TODO: a little race condition is still possible, if the process starts a new subprocess between listing them and killing them
        pgrep -u $(id -u) -P "${pid}"
      fi
  fi
}

# Start service conditionally on crond restart.
sysboot()
{
  # TODO: update this
  dostart=false
  if [ $(get_das_pids | wc -l) = 0 ]; then
      dostart=true
  fi
  $dostart && start
}

wait4mongodb(){
  # TODO: configurable mongodb port?
  echo "waiting for MongoDB to start up. $(date)"
  until nc -z localhost 8230
  do
    sleep 5
  done
}

_sync_mongodb_and_start_das(){
    wait4mongodb \
       </dev/null 2>&1 | rotatelogs $LOGDIR/das-%Y%m%d.log 86400 >/dev/null 2>&1
    syncdata  \
       </dev/null 2>&1 | rotatelogs $LOGDIR/das-%Y%m%d.log 86400 >/dev/null 2>&1
    python -u $DAS_PYTHONPATH/DAS/web/das_server.py \
       </dev/null 2>&1 | rotatelogs $LOGDIR/das-%Y%m%d.log 86400 >/dev/null 2>&1
}

# on service start, update db if needed
sync_mongodb_and_start_das(){
  # like this we can get a PID of subshell, but then killing
  # it it will be important to kill all of its subprocesses
  _sync_mongodb_and_start_das &
  echo $! > "$PID_DAS_SERVER"
  # TO THINK: the redirection of stdin/stdout could also be done here with additional subshell, e.g.:
  # (_sync_mongodb_and_start_das | rotatelogs ...) &
}

# Start the service.
start()
{
  echo "starting $ME"
  sync_mongodb_and_start_das
}

# Stop the service.
stop()
{ 
  echo "stopping $ME"
  # TODO: in unlikely case of a race condition (see get_das_pids()), it might be needed to repeat killing loop until no process is killed
  for pid in $(get_das_pids); do
      kill -9 "$pid"
  done
}

# Check if the server is running.
status()
{
  pid=$(get_das_pids | sort -n)
  if [ X"$pid" = X ]; then
    echo $echo_e "$ME $pat is ${COLOR_WARN}NOT RUNNING${COLOR_NORMAL}."
  else
    echo $echo_e "$ME $pat is ${COLOR_OK}RUNNING${COLOR_NORMAL}, PID" $pid

    # print the status of web-server
    if ! pgrep -u $(id -u) -f "[/]das_server.py" > /dev/null; then
        echo $echo_e "P.S. $ME WEBSERVER is ${COLOR_WARN}NOT RUNNING YET${COLOR_NORMAL}."
    fi
  fi

}

# ensure db_import is not running as the script is changing state in shared dir
check_db_import_not_running(){
    [ $(pgrep -u $(id -u) -f "das_db_import" | wc -l) = 0 ]
}

dasmap_filename(){
    # choose which dasmaps file to use
    local host=`hostname`
    local tbed
    local dbspace  # dbs replica / namespace
    # select a particular dbs replica (prod, dev, int) and version of dasmaps
    case "$host" in vocms133 ) tbed="_testbed" dbspace="_int";; * ) tbed="" dbspace="_prod";; esac
    local mapsfile="das${tbed}_maps_dbs${dbspace}.js"
    echo "$mapsfile"
}

# download metadata and stage it for update
# change is applied on next updatedata() call
fetchdata(){
    local updater_dir="$CFGDIR/metadata_updater"
    local stage_now="$1"

    # fetch datafiles
    # TODO: we could instead just simply use: git pull repo !?
    "$updater_dir/fetch_metadata" "${METADATA_TMP_DIR}"

    echo "Validating and Staging the downloaded files to be imported into MongoDB"
    local mapsfile="${METADATA_TMP_DIR}/$(dasmap_filename)"
    if check_db_import_not_running; then
        das_db_import "stage_update" "${mapsfile}" "${METADATA_TMP_DIR}"
    fi
}

# update metadata from staging area only if needed (to be run from cronjob)
syncdata(){
    echo 'updating database...'
    # make sure import is not running currently
    if check_db_import_not_running; then
        das_db_import "update_if_changed"
    fi
}

# reset data to the default coming from installation.
# this stages the default metadata (dasmaps, inputvals, keylearning), and the
# change is applied on next syncdata() call
resetdata(){
    local dasmaps="$DAS_PYTHONPATH/DAS/services/cms_maps/$(dasmap_filename)"
    das_db_import "stage_update" "$dasmaps"
    # force the full update
    rm -f ${STAGEDIR}/*-schema-stamp
}

# Bootstrap keyword search
bootstrap()
{
    echo "starting keyword search bootstrap (values, fields)"
    das_bootstrap_kws "$@"
    echo "bootstrap done"
}

# Exports kws_data, including keylearning
kws_export_data()
{
    echo "starting exporting KWS data"
    outdir=$STATEDIR/kws_data_exported
    rm -rf $outdir
    mkdir -p $outdir
    das_kws_export_data $outdir
    echo "KWS data exported into: $outdir"
}

# Verify the security string.
check()
{
  CHECK=$(echo "$1" | md5sum | awk '{print $1}')
  if [ $CHECK != 94e261a5a70785552d34a65068819993 ]; then
    echo "$0: cannot complete operation, please check documentation." 1>&2
    exit 2;
  fi
}

# Main routine, perform action requested on command line.
case ${1:-status} in
  sysboot )
    sysboot
    ;;

  start | restart )
    check "$2"
    stop
    start
    ;;

  status )
    status
    ;;

  stop )
    check "$2"
    stop
    ;;

  help )
    perl -ne '/^##H/ && do { s/^##H ?//; print }' < $0
    ;;
    
  syncdata )
    syncdata
    ;;

  fetchdata )
    fetchdata "$@"
    ;;
    
  resetdata )
    resetdata
    ;;

  bootstrap )
    bootstrap
    ;;
    
  kws_export_data )
    kws_export_data
    ;;

  version )
    echo "$DAS_VERSION"
    ;;

  * )
    echo "$0: unknown action '$1', please try '$0 help' or documentation." 1>&2
    exit 1
    ;;
esac
